---
title: 待办及进度
date: 2017-06-02 15:15:46
categories:
tags:
description:
---

| Model              | PCA Size | Threshold | Score  |
| ------------------ | -------- | --------- | ------ |
| Mirror             | 192      | 0.64      | 99.42% |
| Mirror Concat      | 192      | 0.65      | 99.42% |
| Mirror Add/Average | 184      | 0.64      | 99.47% |
| Mirror Max         | 144      | 0.65      | 99.43% |
| Mirror Min         | 168      | 0.65      | 99.48% |
| Mirror Avg+min     | 168      | 0.65      | 99.45% |





| eye_width | num      | eye_width | num    |
| --------- | -------- | --------- | ------ |
| 0~10      | 14       | 90~100    | 8,5674 |
| 10~20     | 3329     | 100~110   | 2,9481 |
| 20~30     | 21,3675  | 110~120   | 9051   |
| 30~40     | 45,1416  | 120~130   | 2894   |
| 40~50     | 49,1913  | 130~140   | 932    |
| 50~60     | 72,8911  | 140~150   | 279    |
| 60~70     | 137,9232 | 150~160   | 86     |
| 70~80     | 128,7442 | 160~170   | 14     |
| 80~90     | 30,9026  | 170~180   | 6      |

![figure](C:\Users\lc\Desktop\test_crop\all\figure.png)


# 问题

1.对于人脸关键点数据中，[eye_left_x,eye_left_y,eye_right_x,eye_right_y...],在进行眼睛宽度估算时，利用eye_width=(eye_right_x-eye_elft_x)*0.78,所以crop后左眼的最左边的坐标公式为eye_left_x-0.5*eye_width，有一种情况没考虑到就是eye_left_x小于0.5*eye_width，所以要加一个判断语句
```
if eye_width*0.5>eye_left_x:
            eye_width=eye_left_x*2
```
导致眼睛宽度估算分布就不太准确，最终导致在mscelebv1_crop数据上，最终符合要求的只有731750张

重新生成眼睛宽度估算文件，其分布如下

| eye_width | num      | eye_width | num  |
| --------- | -------- | --------- | ---- |
| 0~10      | 1,8975   | 100~110   | 98   |
| 10~20     | 71,3760  | 110~120   | 17   |
| 20~30     | 126,4102 | 120~130   | 3    |
| 30~40     | 226,4348 | 130~140   | 0    |
| 40~50     | 59,3351  | 140~150   | 0    |
| 50~60     | 10,6502  | 150~160   | 0    |
| 60~70     | 2,4588   | 160~170   | 1    |
| 70~80     | 5592     | 170~180   | 0    |
| 80~90     | 1588     | 180~190   | 8    |
| 90~100    | 421      | 190~200   | 21   |

![figure2](C:\Users\lc\Desktop\test_crop\all\figure2.png)




2.tripletloss在100次迭代时，loss=nan，原因是初始化的base_lr过大，调小即可
3.test的accuracy一直为0：想到了在清洗数据的时候，有的人物并没有参与，也就是最开始直接用小蔓师兄的标签不行，最后一层的输出不等于我现在数据中的样本类别数。。得自己重新生成，首先要将空目录删除，确定有多少类别，然后label从0开始重新生成。
最后发现我的类别应该是90481.而最后一个全连接层的num_output=90526
